---

layout:     post
title:      3. 无重复字符的最长子串
subtitle:   给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

date:       2019-07-31 23:27

author:     灯火微末

header-img: img/post-bg-re-vs-ng2.jpg

catalog: true

tags:

    - Blog

---



> 正所谓前人栽树，后人乘凉。

> 

> 感谢[Huxpro](https://github.com/huxpro)提供的博客模板

> 

> [我的的博客](http://lsx124.top)



# 题目描述

给定一个字符串，请你找出其中不含有重复字符的 最长子串 的长度。

##示例 1:
```
输入: "abcabcbb"
输出: 3 
解释: 因为无重复字符的最长子串是 "abc"，所以其长度为 3。
```
##示例 2:
```
输入: "bbbbb"
输出: 1
解释: 因为无重复字符的最长子串是 "b"，所以其长度为 1。
```
##示例 3:
```
输入: "pwwkew"
输出: 3
解释: 因为无重复字符的最长子串是 "wke"，所以其长度为 3。
     请注意，你的答案必须是 子串 的长度，"pwke" 是一个子序列，不是子串。
```

# 题解

```
class Solution(object):
    def lengthOfLongestSubstring(self, s):
        """
        :type s: str
        :rtype: int
        """
        dic={}
        i,ans=0,0
        for j in range(len(s)):
            if s[j] in dic:
                i=max(dic[s[j]],i)
            ans=max(ans,j-i+1)
            dic[s[j]]=j+1
        return ans
```

#反思与总结

最初看到这题的时候，就想着，循环去find，但是时间复杂度会很高，估计不少测试案例会通不过。
然后就看到了上述题解。

但是其`i`变化为啥能确保`ans=max(ans,j-i+1)`就是解呢？

反复`debug`后发现，`i`也就是`max(dic[s[j]],i)`就是描述的当前字符在`s`前段出现重复后，字符不重复的最近一个位置，所以，`max(ans,j-i+1)`就是所求。

厘清思路后，再回过头来看，这题难度并不算大，但是期间犯了几个错误：

 - 审题不仔细，题目要求是`不含重复字符的`，结果想成了，`子串不重复`，导致思路岔了；
 - 未能将`不含重复字符的`转化为`寻找某个不包含重复字符串的区间`，导致思绪全无；
 - 因为思绪未转换，导致`debug`上述题解时间耗费太长，一直无法理解`i`如何生效；
 - 还是得多动脑，多思考，要不然脑袋都生锈了
 
###最后的最后，把这些过程记录下来，以便自我反思，自我激励。同时，若您有幸看到，与君共勉！

